[![en](https://img.shields.io/badge/lang-en-green.svg)](README.md)
# ranking-comparators
Несколько шаблонов для составления рейтинговых списков объектов с различными структурами хранения параметров.

### non-nested-params-comparator 
 — это достаточно абстрактная реализация системы,
составляющей ранжированные списки входящих объектов, представленных классом Unit.

Класс Unit хранит в себе Map из параметров, перечисление которых вы задаете сами в классе 
ParamsName. 

Тип хранимого параметра не определен, главное условие - 
реализация интерфейса Comparable. 

В классе Priority вы задаете приоритет каждого параметра, у меня 
это реализовано числом(Integer). Однако численная оценка достаточно субъективна, поэтому я рекомендую прописать вас свой собственный класс-перечисление, и указать его в классе Priority.
(Поскольку Enum, хранящий ONE, TWO, THREE..., будет гарантировать, что любой параметр будет оценен именно по этой шкале,
однако для составления рейтинга это не так важно, поэтому я отпустил этот момент.)

Класс составления рейтинга сравнивает наши Unit друг с другом, по параметрам на основе их приоритета. 

Сравнение происходит по следующему принципу: Компаратор идет от самых приоритетных параметров к наименее приоритетным.  
Процесс сравнения ленивый: если по самому приоритетному параметру есть расхождения, то на остальные параметры он даже не будет смотреть.

*В одном из последних обновлений в компаратор был добавлен флаг на консистентность данных.
Если этот флаг установлен, то перед сравнением элементов, будет проведена валидация, проверяющая, что каждый объект содержит одинаковый набор полей.
Если же этот флаг не установлен, то компаратор будет сравнивать объекты на основе имеющегося набора параметров.*

> Идеальным применением данного алгоритма можно назвать алгоритм составления рейтинговой таблицы футбольных команд в группе:  
Если количество набранных очков равно у нескольких команд, то мы смотрим на разницу в забитых мячах, если количество забитых мячей у нескольких из этих команд одинаковое,
то смотрим на количество пропущенных мячей и так далее.

**Примечание 1**: В этом абстрактном виде безопасное использование класса Unit на уровне компиляции невозможно, поэтому инициализации объектов происходят с использованием Raw Types.  
 Если вы хотите этого избежать, вам нужно больше конкретизации.   
Я исследовал этот вопрос, вы можете найти мое обсуждение на [Stack Overflow](https://stackoverflow.com/questions/78711032)



###### *Исходный код этого проекта написан с использованием AI технологии [Сбера]( http://www.sberbank.ru/) – ассистента разработчика [GigaCode]( https://gigacode.ru/)*