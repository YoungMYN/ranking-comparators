[![en](https://img.shields.io/badge/lang-en-green.svg)](README.md)
# ranking-comparators
Несколько шаблонов для составления рейтинговых списков объектов с различными структурами хранения параметров.

### non-nested-params-comparator 
___
 — это достаточно абстрактная реализация системы,
составляющей ранжированные списки входящих объектов, представленных классом Unit.

Класс Unit хранит в себе Map из параметров, перечисление которых вы задаете сами в классе 
ParamsName. 

Тип хранимого параметра не определен, главное условие - 
реализация интерфейса Comparable. 

В классе Priority вы задаете приоритет каждого параметра, у меня 
это реализовано числом(Integer). Однако численная оценка достаточно субъективна, поэтому я рекомендую прописать вас свой собственный класс-перечисление, и указать его в классе Priority.
(Поскольку Enum, хранящий ONE, TWO, THREE..., будет гарантировать, что любой параметр будет оценен именно по этой шкале,
однако для составления рейтинга это не так важно, поэтому я отпустил этот момент.)

Класс составления рейтинга сравнивает наши Unit друг с другом, по параметрам на основе их приоритета. 

Сравнение происходит по следующему принципу: Компаратор идет от самых приоритетных параметров к наименее приоритетным.  
Процесс сравнения ленивый: если по самому приоритетному параметру есть расхождения, то на остальные параметры он даже не будет смотреть.

*В одном из последних обновлений в компаратор был добавлен флаг на консистентность данных.
Если этот флаг установлен, то перед сравнением элементов, будет проведена валидация, проверяющая, что каждый объект содержит одинаковый набор полей.
Если же этот флаг не установлен, то компаратор будет сравнивать объекты на основе имеющегося набора параметров.*

> Идеальным применением данного алгоритма можно назвать алгоритм составления рейтинговой таблицы футбольных команд в группе:  
Если количество набранных очков равно у нескольких команд, то мы смотрим на разницу в забитых мячах, если количество забитых мячей у нескольких из этих команд одинаковое,
то смотрим на количество пропущенных мячей и так далее.

**Примечание 1**: В этом абстрактном виде безопасное использование класса Unit на уровне компиляции невозможно, поэтому инициализации объектов происходят с использованием Raw Types.  
 Если вы хотите этого избежать, вам нужно больше конкретизации.   
Я исследовал этот вопрос, вы можете найти мое обсуждение на [Stack Overflow](https://stackoverflow.com/questions/78711032)


### tree-nested-params-comparator  
___
— прототип системы, сравнивающей объекты с высокой степенью древовидной вложенности друг с другом.

Каждый объект Person в этом проекте, содержит поле со своими параметрами, представленное объектом класса Params.

У каждого класса также есть N количество детей класса Person, каждый из которых имеет свои параметры(и детей, и параметры, и так до бесконечности).

Предположим, что мы не знаем ничего о степени вложенности входящего объекта, и хотим сравнить его с другим объектом, по какому-либо параметру (в моем случае, допущением системы является то, что сравнение может происходить только по полям, наследующимися от класса Number, то бишь числам. Вы можете изменить эту логику под свои задачи.). Список параметров, по которым возможно провести сравнение, представлен enum’ом CalculatingParam, находящемуся внутри класса Params. Это перечисление хранит имена тех переменных, по которых мы можем сравнить одного Person с другим.

В классе-перечислении CalculatingStrategy представлены некоторые стратегии, по которым возможно провести вычисление над любым из параметров, имя которого перечислено в CalculatingParam.

>Например, CalculatingParam MAX в сочетании с CalculatingParam.AGE при сравнении двух Person ранкирует выше того, у кого в дереве наследования присутствует Person с большим максимальным возрастом, чем у объекта, с которым его сравнивают.

Вы можете сравнивать по среднему возрасту в древе, по суммарному росту среди всех детей, по количеству детей и тд. Опций много и их количество ограничивает только ваше воображение.

_*Важное замечание*_, рекомендуется представлять листы на древовидной структуре наследования (обьектов, не являющихся родительской нодой ни для одного другого обьекта) объектами класса LastDescendant, поскольку он реализует необходимое поведение при вызове недопустимых операций с листом дерева, например, при попытке назначить ссылки на “дочерние элементы” такому узлу, будет выброшено UnsupportedOperationException.

Также такой класс удобен тем, что вы можете реализовать в нем поведение, характерное только для листьев дерева, и безшовно манипулировать поведением объекта через полиморфизм.

>Каждая из моих реализаций классов-ранкеров реализует общий интерфейс Runker с единственным методом List<String> printAndReturnRank(List<T>); При желании вы можете использовать этот интерфейс(а также класс AbstractRanker с реализованым методом-помощником для вывода в консоль ) для своей собственной реализации.


###### *Исходный код этого проекта написан с использованием AI технологии [Сбера]( http://www.sberbank.ru/) – ассистента разработчика [GigaCode]( https://gigacode.ru/)*